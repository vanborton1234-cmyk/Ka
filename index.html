
<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>Ù…ÙˆÙ‚Ø¹ Ø±ÙŠØ§Ø¶ÙŠ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #1e3c72, #2a5298);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #graph, #threeCanvas {
      width: 80vw;
      height: 60vh;
      margin: 20px;
      border: 2px solid white;
      border-radius: 10px;
      background-color: #fff;
    }
    input, button {
      padding: 10px;
      margin: 10px;
      font-size: 1rem;
      border-radius: 5px;
      border: none;
    }
    button {
      background-color: #ff9800;
      color: white;
      cursor: pointer;
    }
    button:hover {
      background-color: #e68900;
    }
  </style>
</head>
<body>
  <h1>ğŸ¯ Ù…ÙˆÙ‚Ø¹ Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª ÙˆØ§Ù„Ù‚Ø·ÙˆØ¹ + Ø£Ø´ÙƒØ§Ù„ Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h1>
  <input type="text" id="equation" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ù…Ø«Ù„: y = x^2 Ø£Ùˆ x^2/4 + y^2/9 = 1" />
  <button onclick="drawEquation()">Ø§Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©</button>
  <div id="graph"></div>
  <div id="threeCanvas"></div>

  <script>
    function drawEquation() {
      const eqInput = document.getElementById("equation").value.trim();
      const xValues = [];
      const yValues = [];

      if (eqInput.includes("=") && eqInput.includes("x") && eqInput.includes("y")) {
        // Ù…Ø¹Ø§Ø¯Ù„Ø© Ù‚Ø·ÙˆØ¹ Ù…Ø«Ù„ x^2/a^2 + y^2/b^2 = 1
        const parts = eqInput.split("=");
        const lhs = parts[0];
        const rhs = parseFloat(parts[1]);

        for (let x = -10; x <= 10; x += 0.1) {
          try {
            const scope = { x };
            const temp = rhs - math.evaluate(lhs.replace(/y/g, "0"), scope);
            if (temp >= 0) {
              const y = Math.sqrt(temp);
              xValues.push(x);
              yValues.push(y);
              xValues.push(x);
              yValues.push(-y);
            }
          } catch (err) {
            alert("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©! ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØµÙŠØºØ©.");
            return;
          }
        }
      } else {
        // Ù…Ø¹Ø§Ø¯Ù„Ø© Ù…Ù† Ø§Ù„Ø´ÙƒÙ„ y = f(x)
        const expr = eqInput.replace("y=", "").trim();
        for (let x = -10; x <= 10; x += 0.1) {
          try {
            const scope = { x };
            const y = math.evaluate(expr, scope);
            xValues.push(x);
            yValues.push(y);
          } catch (err) {
            alert("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©! ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØµÙŠØºØ©.");
            return;
          }
        }
      }

      const trace = {
        x: xValues,
        y: yValues,
        mode: 'lines',
        type: 'scatter',
        line: { color: 'orange', width: 3 }
      };

      const layout = {
        title: 'ğŸ“ˆ Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©',
        paper_bgcolor: '#f0f0f0',
        plot_bgcolor: '#ffffff',
        xaxis: { title: 'x' },
        yaxis: { title: 'y' }
      };

      Plotly.newPlot('graph', [trace], layout);
    }

    // Three.js: Ø´ÙƒÙ„ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù…ØªØ­Ø±Ùƒ
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 0.8, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.6);
    documentconst geometry = new THREE.TorusKnotGeometry(1, 0.3, 100, 16);
    const material = new THREE.MeshStandardMaterial({ color: 0xff9800, metalness: 0.5, roughness: 0.3 });
    const torus = new THREE.Mesh(geometry, material);
    scene.add(torus);
const light = new THREE.PointLight(0xffffff, 1);
light.position.set(5, 5, 5);
scene.add(light);

camera.position.z = 5;

function animate() {
  requestAnimationFrame(animate);
  torus.rotation.x += 0.01;
  torus.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();


  </script>
</body>
</html>
